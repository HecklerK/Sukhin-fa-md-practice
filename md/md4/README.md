# Mobile-development


## <div style="text-align: right">Практика студентов Финансового университета</div>


# Хранение данных
__________________________________________

# [Методичка](http://koroteev.site/md/)


- # Лекция: Работа с поставщиками контента	
Тест https://docs.google.com/forms/d/e/1FAIpQLSdEM7JuKJpehPQR9eNL7EnSHjabultJoCm-7WLAJKYzOTrHbA/viewform

- # Практика: Простое хранение данных

Цель работы

    Научиться сохранять данные и состояние приложения в файле общих настроек, освоить операции чтения и записи в них, восстанавливать состояние из сохраненного файла
## Задания для выполнения
Создайте приложение, единственная активность которого состоит из формы, в которую пользователь вводит следующую информацию о студенте: имя, группа (выбор одного элемента из нескольких заранее определенных), возраст (в виде ползунка), дата рождения (в виде поля ввода даты).
## Методические указания
Для примера разберем более простое приложение, состоящее из одного текстового поля ввода. Для начала создадим макет главной активности:
```xml
<EditText
        android:id="@+id/etName"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:ems="10"
        android:inputType="textPersonName"
        android:text=""
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintTop_toTopOf="parent"/>

    <Button
        android:id="@+id/btnSave"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Сохранить"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintHorizontal_bias="0.174"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintVertical_bias="0.717" />

    <Button
        android:id="@+id/btnLoad"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Восстановить"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintHorizontal_bias="0.937"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintVertical_bias="0.717" />
```

Теперь перейдем к коду. Для начала нам понадобится создать три поля класса, содержащие наши элементы управления, так как мы будем обращаться с ним в нескольких методах:

    Button btnSave, btnLoad;
    EditText etName;

Содержание метода onCreate будет полностью стандартным: привязка к макету, получение ссылок на визуальные элементы и задание обработчиков событий:

    btnSave = findViewById(R.id.btnSave);
    btnLoad = findViewById(R.id.btnLoad);
    etName = findViewById(R.id.etName);

    btnSave.setOnClickListener(this);
    btnLoad.setOnClickListener(this);

Теперь нам осталось создать метод onClick. Автозаполнение студии поможет вам в этом и сделает все за вас автоматически. Как обычно, когда один обработчик события привязан к нескольким элементам, нам понадобится множественный выбор:

```java
@Override
public void onClick(View v) {
   String name = "";
   switch (v.getId()){
       case R.id.btnSave:
           break;
       case R.id.btnLoad:
           break;
       default:
           break;
   }
}
```

Теперь, когда весь вспомогательный код готов, можно приступить к содержательной части - работе с файлом настроек. Для начала заполним ветку сохранения данных. Первым делом нам надо получить ссылку на файл настроек и оттуда получить объект редактора этого файла. Это можно сделать в  две строки:

    SharedPreferences pref = getPreferences(MODE_PRIVATE);
    SharedPreferences.Editor ed = pref.edit();

А можно и в одну, для краткости:

    SharedPreferences.Editor ed = getPreferences(MODE_PRIVATE).edit();

Теперь нам осталось только получить данные из поля ввода и записать их в файл. В файле настроек данные хранятся в виде набора пар имя-значение. Поэтому для записи нам нужно придумать уникальное имя (или ключ) для нашей записи. Это будет первым параметром в методе putString, который и записывает данные в файл настроек. Обратите внимание на команду коммита в редакторе:

    name = etName.getText().toString();
    ed.putString("name", name);
    ed.commit();
    Log.i("SPREF", name);

Еще проще будет заполнение метода чтения данных из файла. Нам всего лишь потребуется опять получить ссылку на файл (получать редактор уже не нужно, ведь мы будем только читать), получить оттуда строку по ключу и записать ее в наше текстовое поле:

    SharedPreferences pref = getPreferences(MODE_PRIVATE);
    name = pref.getString("name", "");
    etName.setText(name);

Основная работа уже сделана. Теперь можно заняться рефакторингом кода. Предоставляем вам самостоятельно выделить всю сутевую часть из обработчиков событий в отдельные функции, добавить другие запоминаемые поля ввода и проверить работоспособность программы.
## Контрольные вопросы
Что такое общие настройки и зачем они нужны?

Чем отличаются приватные и публичные общие настройки?

Какие данные не целесообразно хранить в файле общих настроек?
## Дополнительные задания
Модифицируйте программу таким образом, чтобы все необходимые данные автоматически сохранялись при остановке приложения и восстанавливались при возобновлении работы.

(*) Добавьте возможность в форме делать снимок в камеры телефона. Загруженный снимок должен сохраняться в отдельный файл приложения и так же восстанавливаться при следующем запуске.

(*) Создайте мобильную игру в крестики-нолики используя специально подготовленные графические элементы. 

Модифицируйте программу таким образом, чтобы прогресс игрока сохранялся между запусками программы. Придумайте схему хранения состояния игры.

- # Практика: Файл общих настроек	
	Видео		https://www.youtube.com/watch?v=ELmKfOjzIEU
- # Практика: Внутреннее хранилище	
	Видео		https://www.youtube.com/watch?v=ieQKoc75c_Y
- # Практика: Работа с базой данных

Цель работы

    Научиться пользоваться встроенной реляционной базой данных для хранения андроид приложения, ознакомиться с работой поставщиков контента и разрешений приложения
## Задания для выполнения
Создайте приложение список дел. На главном окне приложения пользователь может создать дело, введя его название, дедлайн (выбор даты и времени), а также необязательно - категорию. При нажатии кнопки “Добавить” дело записывается в базу данных.
## Методические указания
Разберем простой пример, когда в базу данных записывается всего одно поле. На этом примере мы разберем основные механизмы работы с реляционным хранилищем. 

Для начала нам необходимо создать вспомогательный класс, который будет инкапсулировать работу с базой данных. Для этого наследуемся от встроенного класса SQLiteOpenHelper:
```java
public class DBHelper extends SQLiteOpenHelper {
   public DBHelper(Context context) {
   }


   @Override
   public void onCreate(SQLiteDatabase db) {


   }


   @Override
   public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {


   }
}
```

Данный класс должен реализовывать как минимум три приведенных метода. Первый метод - это конструктор, он используется при инициализации данного класса. Сейчас нам нужно только вызвать конструктор суперкласса. У конструктора 4 параметра: контекст, название базы данных, фабричный метод (в простых примерах он нам не понадобится) и версия базы данных, которая используется для организации миграций:
```java
   public DBHelper(Context context) {
       super(context, "MyDB", null, 1);
   }
```

Второй метод используется один раз при создании базы данных. В нем реализуется код, который создает схему данных и при необходимости наполняет базу начальными данными. Обратите внимание, что этот код выполняется только тогда, когда мы пытаемся подключиться к базе, которой еще не существует. Обычно, хорошим тоном при проектировании баз данных является использование специальных контрактных классов, которые абстрагируют реальные названия полей и таблиц, но так как у нас упрощенный пример мы реализуем код сразу по месту:
```java
@Override
public void onCreate(SQLiteDatabase db) {
   // создаем таблицу с полями
   db.execSQL("create table mytable ("
           + "id integer primary key autoincrement,"
           + "name text" + ");");


}
```

То есть это обычная конструкция SQL. В принципе, все остальные операции с базой данных вы тоже можете делать при помощи чистого языка запросов, но это слишком низкоуровневый подход. Большую часть черновой работы фреймворк делает за нас.

И последний метод используется для обновления схемы данных при миграциях. Мы не будем пока использовать эту возможность поэтому оставим данный метод пустым.

После создания вспомогательного класса можно приступить к наполнения макета. Не будем приводить его полностью. 

В данном примере мы сделаем одно поле ввода и три кнопки, которые будут реализовывать самые базовые операции с БД: запись новой строки в таблицу, чтение всех строк из таблицы и очистка таблицы.
```java
<EditText
   android:id="@+id/etName"
   android:layout_width="wrap_content"
   android:layout_height="wrap_content"
   android:ems="10"
   android:inputType="textPersonName"
   android:text=""
   app:layout_constraintBottom_toBottomOf="parent"
   app:layout_constraintLeft_toLeftOf="parent"
   app:layout_constraintRight_toRightOf="parent"
   app:layout_constraintTop_toTopOf="parent"/>

<Button
   android:id="@+id/btnAdd"
   android:layout_width="wrap_content"
   android:layout_height="wrap_content"
   android:text="Добавить"
   app:layout_constraintBottom_toBottomOf="parent"
   app:layout_constraintHorizontal_bias="0.054"
   app:layout_constraintLeft_toLeftOf="parent"
   app:layout_constraintRight_toRightOf="parent"
   app:layout_constraintTop_toTopOf="parent"
   app:layout_constraintVertical_bias="0.717" />

<Button
   android:id="@+id/btnDelete"
   android:layout_width="wrap_content"
   android:layout_height="wrap_content"
   android:text="Удалить"
   app:layout_constraintBottom_toBottomOf="parent"
   app:layout_constraintLeft_toLeftOf="parent"
   app:layout_constraintRight_toRightOf="parent"
   app:layout_constraintTop_toTopOf="parent"
   app:layout_constraintVertical_bias="0.717" />

<Button
   android:id="@+id/btnRead"
   android:layout_width="wrap_content"
   android:layout_height="wrap_content"
   android:text="Получить"
   app:layout_constraintBottom_toBottomOf="parent"
   app:layout_constraintHorizontal_bias="0.945"
   app:layout_constraintLeft_toLeftOf="parent"
   app:layout_constraintRight_toRightOf="parent"
   app:layout_constraintTop_toTopOf="parent"
   app:layout_constraintVertical_bias="0.717" />
```

Теперь мы можем переходит непосредственно к коду главной активности. Для начала создадим необходимые поля класса:

    Button btnAdd, btnDelete, btnRead;
    EditText etName;
    DBHelper dbHelper;

Далее как всегда мы получим ссылки на эти элементы и привяжем обработчик событий к кнопкам:

       btnAdd = findViewById(R.id.btnAdd);
       btnDelete = findViewById(R.id.btnDelete);
       btnRead = findViewById(R.id.btnRead);
       etName = findViewById(R.id.etName);
       btnAdd.setOnClickListener(this);
       btnDelete.setOnClickListener(this);
       btnRead.setOnClickListener(this);

Обратите внимание, что заодно мы инстанцировали наш вспомогательный класс:

       dbHelper = new DBHelper(this);

Теперь займемся непосредственно обработчиком. В нем мы должны будем получить текст, введенный пользователем, создать вспомогательный объект записи, получить ссылку на саму базу данных и организовать множественный выбор как всегда в таких случаях:
```java
   @Override
   public void onClick(View v) {


       String name = etName.getText().toString();
       ContentValues cv = new ContentValues();
       SQLiteDatabase db = dbHelper.getWritableDatabase();


       switch (v.getId()){
           case R.id.btnAdd:
               break;
           case R.id.btnDelete:
               break;
           case R.id.btnRead:
               break;
           default:
               break;
       }
   }
```

Еще в конце этого метода можно закрыт подключение к базе данных для экономии ресурсов. Реализуйте это самостоятельно.

Обратите внимание на вспомогательный объект ContentValues. Они используется для хранения структурированной записи в формате ключ-значение. 

Именно такая запись и нужна для добавления строки в базу данных. Еще обратите внимание на то, как мы получаем ссылку на саму базу данных - через встроенный метод нашего вспомогательного класса.

Теперь приступим к добавлению строки. Нам остается только создать строку и записать ее в бд в соответствующей ветке:

    cv.put("name", name);
    db.insert("mytable", null, cv);

Обратите внимание, что название поля и название таблицы должно соответствовать нашей схеме данных из вспомогательного класса. Именно для того, чтобы не повторяться каждый раз в программе и нужны контрактные классы, однако мы пока обойдемся без них.

Реализуем еще одну простую операцию - удаление данных. Она тоже уже есть в виде встроенных методов, нам только нужно ими воспользоваться:

    db.delete("mytable", null, null);

У данного метода три параметра: имя таблицы, условия и параметры условий. Условия мы не задаем, что соответствует оператору DELETE без блока WHERE в классическом SQL. На практике, обычно данные из базы удаляются именно по условиям, поэтому посмотрите в документации или в лекциях, как задаются условия. Схема здесь общая и для удаления, и для обновления и для выборки, как и в самом SQL. 

Более сложная операция - это чтение из базы. Для этого нам понадобится промежуточный объект - курсор. Именно его возвращает метод запроса, который соответствует оператору SQL SELECT:

    Cursor c = db.query("mytable", null, null, null, null, null, null);

У этого метода довольно много параметров. Давайте перечислим их:
- Имя таблицы. Это понятно, мы должны указать, из какой таблицы происходит выборка.
- Колонки. Также мы можем указать, какие именно столбцы будут отбираться. Если, как выше мы не указали имена столбцов, то в результате нам вернуться все.
- Условия отбора. Здесь мы можем задать условия, то есть как в блоке WHERE. Можно задать одно или несколько условий. Или не задавать вообще, как мы в примере.
- Параметры условий. Здесь задаются конкретные значения, используемые в условиях отбора. В SQL это выглядит более органично, когда они задаются вместе с самими условиями, но использование фреймворка добавляет своих условностей.
- Группировка. Также можно задать группировку значений.
- Условия. Это аналог блока HAVING в SQL. Здесь задаются групповый условия отбора.
- Сортировка. Также можно задать порядок, то есть один или несколько столбцов, по которым будут отсортированы значения.

И этот сложный и мощный метод возвращает нам специальный объект - курсор, который используется для итерирования по результату отбора. Курсор указывает на определенную строку результата и его можно передвигать на следующую, пока мы не достигнем конца выдачи. Нужно всегда помнить, что такой результат может содержать ноль или более строк. Мы хотим вывести все строки для простоты в консоль, но вообще их можно положить в определенную структуру и связать, например, со списочным представлением в интерфейсе.

Но вначале всегда следует проверить, вернулось ли нам вообще что-нибудь, то есть проверить количество строк. И вот здесь может быть немного сложно. Ведь курсор - это не массив, это именно итератор. И такого понятия как размер у него нет. Поэтому проверка наличия результата проходит немного непривычно:
```java
if (c.moveToFirst()) {
} else
   Log.d("LOG_TAG", "0 rows");
c.close();
```
Обратите внимание на использованный метод. Он возвращает истину, если в курсоре еще есть данные. В противном случае мы просто выводим сообщение, что в таблице нет строк. Все дальнейшие действия мы будем производить в положительной ветке данного условия. Ну и после всего условия мы должны закрыть данный курсор.

Теперь мы будем итерировать по курсору и вытаскивать нужные нам данные. И еще одна условность. Доступ к данным в курсоре происходит по номеру столбца. Мы, конечно, можем запомнить какой столбец какой номер имеет, но это непродуктивно. Лучше воспользоваться специальным методом:
```java
int idColIndex = c.getColumnIndex("id");
int nameColIndex = c.getColumnIndex("name");
Осталось организовать цикл по курсору и выбрать необходимые данные:
do {
   Log.d("LOG_TAG",
           "ID = " + c.getInt(idColIndex) +
                   ", name = " + c.getString(nameColIndex));
} while (c.moveToNext());
```

Также отметим, что методы доступа к данным являются типизированными, так что вы должны знать тип данных в каждом столбце таблицы, с которым планируете работать.

Основные операции выполнены. Остальные операции с базой данных осуществляются аналогично. Предоставляем вам самостоятельно расширить схему данных и включить в приложение остальные операции работы с базой данных.
## Контрольные вопросы
Что такое контрактные классы и как они облегчают работу со схемой базы данных?

Что такое миграции базы данных и как их реализовать?

Какие методы объекта SQLiteDatabase соответствуют другим операторам языка SQL?

Зачем нужны контент-провайдеры и чем они отличаются от контент-резолверов?

Зачем нужно объектно-реляционное отображение?
## Дополнительные задания
Модифицируйте программу таким образом, чтобы все действия с базой данных выполнялись в отдельных функциях.

(*) Добавьте в программу возможность динамически просматривать записи в базе данных с помощью RecyclerView. Создайте адаптер и свяжите его с базой данных. Возможно, придется использовать сторонние компоненты для реализации адаптера, поддерживающего курсоры.

Создайте на главном окне программы список дел, читаемый из базы данных, а окно добавления дела сделайте второй активностью вызываемой по кнопке. 

(*) Реализуйте в своем приложении контент провайдер, который предоставляет доступ другим приложениям к записям по студентам из своей базы данных. Ограничьте доступ к базе данных при помощи разрешения уровня компонента. 

